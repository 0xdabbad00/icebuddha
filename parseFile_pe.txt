<<<<<<< HEAD
class Parse:
    def run(self, data):
        self.parser = []
        #for i in data:
        #    self.parser.append(i+1)

        child = self.node("child_label", "MZ_SIGNATURE", "/* sig */", 0, 2)
        imgDosHeader = self.node("Label", "IMAGE_DOS_HEADER", "comment", 0, 2)
        self.addChild(imgDosHeader, child)
        
        self.parser.append(imgDosHeader)
        return self.parser

    def node(self, label, name, comment, offset, size):
        return [label, size, name, comment, offset, []]

    def addChild(self, parent, child):
        parent[5].append(child)
        return parent

parser = Parse()
=======
typedef struct IMAGE_DOS_HEADER {
	WORD  e_magic;      /* MZ Header signature */
	WORD  e_cblp;       /* Bytes on last page of file */
	WORD  e_cp;         /* Pages in file */
	WORD  e_crlc;       /* Relocations */
	WORD  e_cparhdr;    /* Size of header in paragraphs */
	WORD  e_minalloc;   /* Minimum extra paragraphs needed */
	WORD  e_maxalloc;   /* Maximum extra paragraphs needed */
	WORD  e_ss;         /* Initial (relative) SS value */
	WORD  e_sp;         /* Initial SP value */
	WORD  e_csum;       /* Checksum */
	WORD  e_ip;         /* Initial IP value */
	WORD  e_cs;         /* Initial (relative) CS value */
	WORD  e_lfarlc;     /* File address of relocation table */
	WORD  e_ovno;       /* Overlay number */
	WORD  e_res[4];     /* Reserved words */
	WORD  e_oemid;      /* OEM identifier (for e_oeminfo) */
	WORD  e_oeminfo;    /* OEM information; e_oemid specific */
	WORD  e_res2[10];   /* Reserved words */
	DWORD e_lfanew;     /* Offset to extended header */
} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

typedef struct IMAGE_FILE_HEADER {
	WORD  Machine;
	WORD  NumberOfSections;
	DWORD TimeDateStamp;
	DWORD PointerToSymbolTable;
	DWORD NumberOfSymbols;
	WORD  SizeOfOptionalHeader;
	WORD  Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

typedef struct IMAGE_DATA_DIRECTORY {
	DWORD VirtualAddress;
	DWORD Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

typedef struct IMAGE_OPTIONAL_HEADER {
	WORD  Magic;
	BYTE  MajorLinkerVersion;
	BYTE  MinorLinkerVersion;
	DWORD SizeOfCode;
	DWORD SizeOfInitializedData;
	DWORD SizeOfUninitializedData;
	DWORD AddressOfEntryPoint;            
	DWORD BaseOfCode;
	DWORD BaseOfData;
	DWORD ImageBase;
	DWORD SectionAlignment;               
	DWORD FileAlignment;
	WORD  MajorOperatingSystemVersion;
	WORD  MinorOperatingSystemVersion;
	WORD  MajorImageVersion;
	WORD  MinorImageVersion;
	WORD  MajorSubsystemVersion;
	WORD  MinorSubsystemVersion;
	DWORD Win32VersionValue;
	DWORD SizeOfImage;
	DWORD SizeOfHeaders;
	DWORD CheckSum;   
	WORD  Subsystem;
	WORD  DllCharacteristics;
	DWORD SizeOfStackReserve;
	DWORD SizeOfStackCommit;
	DWORD SizeOfHeapReserve;
	DWORD SizeOfHeapCommit;
	DWORD LoaderFlags;
	DWORD NumberOfRvaAndSizes;
	// IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;


typedef struct IMAGE_OPTIONAL_HEADER64 {
	WORD        Magic;
	BYTE        MajorLinkerVersion;
	BYTE        MinorLinkerVersion;
	DWORD       SizeOfCode;
	DWORD       SizeOfInitializedData;
	DWORD       SizeOfUninitializedData;
	DWORD       AddressOfEntryPoint;
	DWORD       BaseOfCode;
	ULONGLONG   ImageBase;
	DWORD       SectionAlignment;
	DWORD       FileAlignment;
	WORD        MajorOperatingSystemVersion;
	WORD        MinorOperatingSystemVersion;
	WORD        MajorImageVersion;
	WORD        MinorImageVersion;
	WORD        MajorSubsystemVersion;
	WORD        MinorSubsystemVersion;
	DWORD       Win32VersionValue;
	DWORD       SizeOfImage;
	DWORD       SizeOfHeaders;
	DWORD       CheckSum;
	WORD        Subsystem;
	WORD        DllCharacteristics;
	ULONGLONG   SizeOfStackReserve;
	ULONGLONG   SizeOfStackCommit;
	ULONGLONG   SizeOfHeapReserve;
	ULONGLONG   SizeOfHeapCommit;
	DWORD       LoaderFlags;
	DWORD       NumberOfRvaAndSizes;
	// IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;

typedef struct IMAGE_NT_HEADERS {
  DWORD                 Signature;
} IMAGE_NT_HEADERS, *PIMAGE_NT_HEADERS;


// IMAGE_DOS_HEADER
var imageDosHeader = parseStruct(0, IMAGE_DOS_HEADER);
treedata.push(imageDosHeader);

// IMAGE_NT_HEADERS
var e_lfanew = imageDosHeader.getValue("e_lfanew");
var imageNtHeader = parseStruct(e_lfanew, IMAGE_NT_HEADERS);
treedata.push(imageNtHeader);

// IMAGE_FILE_HEADER
var sizeof_magic = 4;
var imageFileHeader = parseStruct(e_lfanew + sizeof_magic, IMAGE_FILE_HEADER);

// IMAGE_OPTIONAL_HEADER
var machine = imageFileHeader.getValue("Machine");
var imageOptionalHeader;
if (machine == 0x014c) {
	imageOptionalHeader = parseStruct(imageFileHeader.end(), IMAGE_OPTIONAL_HEADER);
} else if (machine == 0x8664) {
	imageOptionalHeader = parseStruct(imageFileHeader.end(), IMAGE_OPTIONAL_HEADER64);
} else {
	console.log("ERROR: machine type unknown:"+machine);
}

imageOptionalHeader.interpret("DllCharacteristics", function(value) { 
	result = [];
	// 0x0001 reserved
	// 0x0002 reserved
	// 0x0004 reserved
	// 0x0008 reserved
	if (value & 0x0040) { result.push("DYNAMIC_BASE"); }
	if (value & 0x0080) { result.push("FORCE_INTEGRITY"); }
	if (value & 0x0100) { result.push("NX_COMPAT"); }
	if (value & 0x0200) { result.push("NO_ISOLATION"); }
	if (value & 0x0400) { result.push("NO_SEH"); }
	if (value & 0x0800) { result.push("NO_BIND"); }
	// 0x1000 reserved
	if (value & 0x2000) { result.push("WDM_DRIVER"); }
	// 0x4000 reserved
	if (value & 0x8000) { result.push("TERMINAL_SERVER_AWARE"); }

	return result.join("|");
	});

imageNtHeader.append(imageFileHeader);
imageNtHeader.append(imageOptionalHeader);

imageOptionalHeader.append(parseStruct(imageOptionalHeader.end(), IMAGE_DATA_DIRECTORY, "export table"));
imageOptionalHeader.append(parseStruct(imageOptionalHeader.end(), IMAGE_DATA_DIRECTORY, "import table"));


>>>>>>> 3a08130335a50fb1da213a374fce36b8fe9cb9ae
