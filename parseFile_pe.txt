typedef struct IMAGE_DOS_HEADER {
	WORD  e_magic;      /* MZ Header signature */
	WORD  e_cblp;       /* Bytes on last page of file */
	WORD  e_cp;         /* Pages in file */
	WORD  e_crlc;       /* Relocations */
	WORD  e_cparhdr;    /* Size of header in paragraphs */
	WORD  e_minalloc;   /* Minimum extra paragraphs needed */
	WORD  e_maxalloc;   /* Maximum extra paragraphs needed */
	WORD  e_ss;         /* Initial (relative) SS value */
	WORD  e_sp;         /* Initial SP value */
	WORD  e_csum;       /* Checksum */
	WORD  e_ip;         /* Initial IP value */
	WORD  e_cs;         /* Initial (relative) CS value */
	WORD  e_lfarlc;     /* File address of relocation table */
	WORD  e_ovno;       /* Overlay number */
	WORD  e_res[4];     /* Reserved words */
	WORD  e_oemid;      /* OEM identifier (for e_oeminfo) */
	WORD  e_oeminfo;    /* OEM information; e_oemid specific */
	WORD  e_res2[10];   /* Reserved words */
	DWORD e_lfanew;     /* Offset to extended header */
} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

typedef struct IMAGE_FILE_HEADER {
  WORD  Machine;
  WORD  NumberOfSections;
  DWORD TimeDateStamp;
  DWORD PointerToSymbolTable;
  DWORD NumberOfSymbols;
  WORD  SizeOfOptionalHeader;
  WORD  Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

typedef struct IMAGE_DATA_DIRECTORY {
  DWORD VirtualAddress;
  DWORD Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

typedef struct IMAGE_OPTIONAL_HEADER {
	WORD  Magic;
	BYTE  MajorLinkerVersion;
	BYTE  MinorLinkerVersion;
	DWORD SizeOfCode;
	DWORD SizeOfInitializedData;
	DWORD SizeOfUninitializedData;
	DWORD AddressOfEntryPoint;            
	DWORD BaseOfCode;
	DWORD BaseOfData;
	DWORD ImageBase;
	DWORD SectionAlignment;               
	DWORD FileAlignment;
	WORD  MajorOperatingSystemVersion;
	WORD  MinorOperatingSystemVersion;
	WORD  MajorImageVersion;
	WORD  MinorImageVersion;
	WORD  MajorSubsystemVersion;
	WORD  MinorSubsystemVersion;
	DWORD Win32VersionValue;
	DWORD SizeOfImage;
	DWORD SizeOfHeaders;
	DWORD CheckSum;   
	WORD  Subsystem;
	WORD  DllCharacteristics;
	DWORD SizeOfStackReserve;
	DWORD SizeOfStackCommit;
	DWORD SizeOfHeapReserve;
	DWORD SizeOfHeapCommit;
	DWORD LoaderFlags;
	DWORD NumberOfRvaAndSizes;
} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;


typedef struct IMAGE_OPTIONAL_HEADER64 {
 WORD        Magic;
 BYTE        MajorLinkerVersion;
 BYTE        MinorLinkerVersion;
 DWORD       SizeOfCode;
 DWORD       SizeOfInitializedData;
 DWORD       SizeOfUninitializedData;
 DWORD       AddressOfEntryPoint;
 DWORD       BaseOfCode;
 ULONGLONG   ImageBase;
 DWORD       SectionAlignment;
 DWORD       FileAlignment;
 WORD        MajorOperatingSystemVersion;
 WORD        MinorOperatingSystemVersion;
 WORD        MajorImageVersion;
 WORD        MinorImageVersion;
 WORD        MajorSubsystemVersion;
 WORD        MinorSubsystemVersion;
 DWORD       Win32VersionValue;
 DWORD       SizeOfImage;
 DWORD       SizeOfHeaders;
 DWORD       CheckSum;
 WORD        Subsystem;
 WORD        DllCharacteristics;
 ULONGLONG   SizeOfStackReserve;
 ULONGLONG   SizeOfStackCommit;
 ULONGLONG   SizeOfHeapReserve;
 ULONGLONG   SizeOfHeapCommit;
 DWORD       LoaderFlags;
 DWORD       NumberOfRvaAndSizes;
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;

typedef struct IMAGE_NT_HEADERS {
  DWORD                 Signature;
} IMAGE_NT_HEADERS, *PIMAGE_NT_HEADERS;


var imageDosHeader = parseStruct(0, IMAGE_DOS_HEADER);
treedata.push(imageDosHeader);

var e_lfanew = imageDosHeader.getValue("e_lfanew");
var imageNtHeader = parseStruct(e_lfanew, IMAGE_NT_HEADERS);
treedata.push(imageNtHeader);

var sizeof_magic = 4;
var imageFileHeader = parseStruct(e_lfanew + sizeof_magic, IMAGE_FILE_HEADER);

var machine = imageFileHeader.getValue("Machine");
var imageOptionalHeader;
if (machine == 0x014c) {
	imageOptionalHeader = parseStruct(imageFileHeader.end(), IMAGE_OPTIONAL_HEADER);
} else if (machine == 0x8664) {
	imageOptionalHeader = parseStruct(imageFileHeader.end(), IMAGE_OPTIONAL_HEADER64);
} else {
	console.log("ERROR: machine type unknown:"+machine);
}

imageOptionalHeader.append(parseStruct(imageOptionalHeader.end(), IMAGE_DATA_DIRECTORY, "export table"));
imageOptionalHeader.append(parseStruct(imageOptionalHeader.end(), IMAGE_DATA_DIRECTORY, "import table"));

imageNtHeader.append(imageFileHeader);
imageNtHeader.append(imageOptionalHeader);
